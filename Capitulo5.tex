\section{Sistema Propuesto}

En esta sección se detalla el diseño y la arquitectura del \textit{Nez-Daemon Watcher}, un servicio de software diseñado para funcionar como un **agente de ingesta de datos** para el **Espacio de Almacenamiento Virtual (VSS) de MictlanX**. El rol principal de este componente es actuar como una puerta de enlace robusta y desatendida entre un sistema de archivos local y el ecosistema de almacenamiento distribuido de MictlanX, centrándose en la eficiencia, la resiliencia y la automatización.

\subsection{Análisis de Requerimientos}
El análisis de requerimientos es la base sobre la cual se construye el sistema, definiendo las capacidades y restricciones del mismo.

\subsubsection{Requerimientos Funcionales}
Los requerimientos funcionales describen las operaciones principales que el sistema puede ejecutar para cumplir su misión como agente de ingesta.

\begin{itemize}
    \item \textbf{RF-01: Monitoreo de Directorio.} El sistema debe monitorear de forma continua y recursiva un directorio predefinido (\texttt{watch\_dir}). Esta es la principal fuente de eventos que dispara el flujo de trabajo de carga de archivos.
    
    \item \textbf{RF-02: Carga de Archivos a MictlanX.} Al detectar un nuevo archivo, el sistema debe orquestar su carga al VSS de MictlanX. Este proceso implica almacenar el archivo como un objeto atómico denominado \textbf{Ball} dentro de un contenedor lógico llamado \textbf{Bucket}. La carga debe incluir metadatos clave como el checksum SHA-256 (para integridad), el tamaño, y un factor de replicación (\texttt{replication\_factor}) que instruye a MictlanX sobre cuántas copias del "Ball" deben distribuirse entre los nodos de almacenamiento (\textbf{Peers}) para garantizar la redundancia.
    
    \item \textbf{RF-03: Verificación de Existencia.} Para optimizar el uso de la red y el almacenamiento, el sistema debe verificar si un "Ball" con la misma clave ya existe en el "Bucket" de MictlanX antes de iniciar una carga, evitando así la duplicación de datos.
    
    \item \textbf{RF-04: Gestión de Cuarentena.} Para asegurar la alta disponibilidad, si un archivo falla repetidamente durante el proceso de carga, debe ser movido a un directorio de "cuarentena", aislando los archivos problemáticos sin detener el servicio.
    
    \item \textbf{RF-05: Manejo de Solicitudes de Descarga.} El sistema debe ser capaz de procesar solicitudes de descarga desde MictlanX, actuando como un punto de acceso local al VSS. Los dos mecanismos soportados son a través de archivos \texttt{.mictlanx\_download} y un socket de dominio Unix para comunicación entre procesos (IPC).
\end{itemize}

\subsubsection{Requerimientos No Funcionales}
Los requerimientos no funcionales definen las características de calidad y operativas que garantizan que el sistema sea eficiente y robusto.

\begin{itemize}
    \item \textbf{RNF-01: Concurrencia.} El sistema debe procesar múltiples archivos de forma concurrente mediante un grupo de "trabajadores" asíncronos para maximizar el rendimiento.
    
    \item \textbf{RNF-02: Estabilidad de Archivo.} Antes de procesar un archivo, el sistema debe esperar un breve período para asegurar que la operación de escritura ha finalizado por completo, evitando así la ingesta de datos corruptos o incompletos.
    
    \item \textbf{RNF-03: Resiliencia.} Las operaciones de red deben ser resilientes a fallos transitorios, utilizando una estrategia de reintentos con retroceso exponencial para las llamadas a la API de MictlanX.
    
    \item \textbf{RNF-04: Configurabilidad.} Siguiendo la metodología de 12-Factores, la configuración del sistema (rutas, URI del Router de MictlanX, etc.) debe ser externa al código y gestionada mediante variables de entorno.
    
    \item \textbf{RNF-05: Portabilidad.} El sistema está empaquetado como una imagen Docker \cite{merkel2014docker}, garantizando un entorno de ejecución consistente y simplificando su despliegue.
\end{itemize}

\subsection{El Ecosistema de Almacenamiento MictlanX}
Para comprender el rol y el diseño del \textit{Nez-Daemon Watcher}, es fundamental primero describir el sistema de almacenamiento con el que se integra. MictlanX no es un sistema de almacenamiento monolítico, sino un **Espacio de Almacenamiento Virtual (VSS)**, una abstracción programable sobre un conjunto de recursos de almacenamiento distribuidos. Su propósito es ofrecer una plataforma de almacenamiento flexible, elástica y resiliente.

La arquitectura de MictlanX, basada en el repositorio \texttt{mictlanx-service}, se compone de tres entidades principales que operan de forma desacoplada:
\begin{itemize}
    \item \textbf{Storage Peers (Pares de Almacenamiento):} Son los nodos de almacenamiento individuales y autónomos. Su única responsabilidad es guardar los datos físicos que se les entregan. En la terminología de MictlanX, la unidad atómica de datos es un \textbf{Ball}.
    
    \item \textbf{Storage Replica Management (SPM):} Es el cerebro o la "autoridad de metadatos" del ecosistema. El SPM es un subsistema distribuido que mantiene un registro global del estado del clúster. Sabe qué Peers están activos, qué "Balls" existen, en qué "Peers" reside cada réplica de un "Ball", y cómo están organizados lógicamente dentro de contenedores llamados \textbf{Buckets}.
    
    \item \textbf{Router (Enrutador):} Es el único punto de entrada y el orquestador de operaciones de entrada/salida (I/O) para todo el VSS. Los clientes, como el \textit{Nez-Daemon Watcher}, no interactúan directamente con los Peers o el SPM. Toda la comunicación se realiza a través de la API del Router.
\end{itemize}

Cuando el Watcher necesita cargar un archivo, se comunica con el Router. El Router, a su vez, consulta al SPM para tomar decisiones inteligentes sobre dónde y cómo almacenar el archivo (por ejemplo, seleccionando los Peers menos cargados y asegurando el factor de replicación solicitado). Una vez tomada la decisión, el Router guía al cliente para que complete la transferencia de datos. Esta arquitectura desacoplada, que separa la gestión de metadatos (el "plano de control" del SPM) de las operaciones de datos (el "plano de datos" del Router y los Peers), es lo que le da a MictlanX su escalabilidad y flexibilidad. El \textit{Nez-Daemon Watcher} actúa, por tanto, como un cliente especializado que traduce eventos del sistema de archivos en operaciones complejas dentro de este ecosistema distribuido.

\subsection{Arquitectura del Sistema}
La arquitectura del \textit{Nez-Daemon Watcher}, descrita en esta sección, está diseñada específicamente para funcionar como un componente de borde (edge component) eficiente y robusto para el VSS de MictlanX. Su diseño modular y orientado a eventos le permite abstraer la complejidad del ecosistema de almacenamiento y operar de forma autónoma. La Figura \ref{fig:arquitectura_watcher} ilustra la interacción entre sus componentes internos.

\begin{figure}[h]
    \centering
    % Código fuente en Diagramas UML/arquitectura.puml
    \includegraphics[width=\textwidth]{Diagramas UML/arquitectura.png}
    \caption{Diagrama de alto nivel de la arquitectura del Watcher.}
    \label{fig:arquitectura_watcher}
\end{figure}

\subsubsection{Componentes del Watcher}
\begin{itemize}
    \item \textbf{Orquestador Principal (\texttt{watcher.py}):} Inicia y supervisa todos los componentes. Realiza una comprobación de salud inicial contra el Router de MictlanX antes de empezar a operar.
    
    \item \textbf{Observador del Sistema de Archivos (\texttt{NewFileHandler}):} Utiliza \texttt{watchdog} \cite{watchdog2023docs} para detectar eventos y actúa como un puente hacia el bucle de eventos asíncrono de la aplicación.
    
    \item \textbf{Cola de Tareas (\texttt{asyncio.Queue}):} Búfer central que desacopla la detección de eventos del procesamiento, permitiendo al sistema gestionar picos de trabajo.
    
    \item \textbf{Trabajadores (\texttt{worker}):} Tareas asíncronas que consumen eventos de la cola y ejecutan la lógica de negocio.
    
    \item \textbf{Módulo de Operaciones MictlanX (\texttt{mictlanx\_ops.py}):} Abstrae la comunicación con el Router de MictlanX. Su función más importante es implementar el proceso de carga en dos fases dictado por la arquitectura de MictlanX.
    
    \item \textbf{Servidor de Socket (\texttt{socket\_server.py}):} Expone un socket de dominio Unix para recibir órdenes de otros procesos locales.
\end{itemize}

\subsection{Diagrama de Contexto}
El diagrama de contexto, mostrado en la Figura \ref{fig:contexto}, posiciona al sistema como un servicio intermediario entre el entorno local y el VSS de MictlanX.

\begin{figure}[h]
    \centering
    % Código fuente en Diagramas UML/contexto.puml
    \includegraphics[width=\textwidth]{Diagramas UML/contexto.png}
    \caption{Diagrama de Contexto del Sistema Watcher.}
    \label{fig:contexto}
\end{figure}

Las entidades externas son:
\begin{itemize}
    \item \textbf{Usuario/Administrador:} Inicia y configura el servicio.
    \item \textbf{Sistema de Archivos:} El entorno local que el watcher monitorea.
    \item \textbf{Router de MictlanX (VSS):} El punto de entrada al sistema de almacenamiento distribuido, con el que se comunica vía API REST.
    \item \textbf{Aplicación Cliente Local:} Proceso local que solicita descargas vía socket.
\end{itemize}

\subsection{Diagramas de Casos de Uso}
Los casos de uso definen las interacciones funcionales clave. La Figura \ref{fig:casos_uso} muestra su representación gráfica.

\begin{figure}[h]
    \centering
    % Código fuente en Diagramas UML/casos_de_uso.puml
    \includegraphics[width=0.8\textwidth]{Diagramas UML/casos_de_uso.png}
    \caption{Diagrama de Casos de Uso.}
    \label{fig:casos_uso}
\end{figure}

\subsection{Diagramas UML}
El diagrama de secuencia en la Figura \ref{fig:diagrama_secuencia} detalla el flujo de la carga de un archivo, evidenciando la comunicación exclusiva con el Router de MictlanX.

\begin{figure}[h]
    \centering
    % Código fuente en Diagramas UML/secuencia_carga.puml
    \includegraphics[width=\textwidth]{Diagramas UML/secuencia_carga.png}
    \caption{Diagrama de Secuencia para la carga de un nuevo archivo.}
    \label{fig:diagrama_secuencia}
\end{figure}

La secuencia es:
\begin{enumerate}
    \item El \texttt{Observador} detecta un archivo y encola una tarea.
    \item Un \texttt{Trabajador} toma la tarea.
    \item El \texttt{Trabajador} invoca al módulo de \texttt{Operaciones MictlanX}.
    \item El módulo de operaciones envía una petición de registro de metadatos al \texttt{Router de MictlanX}. El Router consulta al SPM y devuelve un ID de tarea.
    \item El módulo de operaciones envía el contenido del archivo al \texttt{Router}, usando el ID de tarea. El Router gestiona la transferencia a los Peers apropiados.
\end{enumerate}

\subsection{Diseño de Entradas y Salidas}
Las entradas y salidas del sistema se definen a nivel de datos y protocolos.

\subsubsection{Entradas del Sistema}
\begin{itemize}
    \item \textbf{Archivos en Directorio:} Archivos binarios de cualquier tipo.
    \item \textbf{Mensajes de Socket:} Cadenas de texto UTF-8 con la ruta del recurso a descargar.
    \item \textbf{Variables de Entorno:} Pares clave-valor para la configuración.
\end{itemize}

\subsubsection{Salidas del Sistema}
\begin{itemize}
    \item \textbf{Llamadas a la API del Router de MictlanX:} Peticiones HTTP POST a los endpoints \texttt{/api/v4/buckets/metadata} y \texttt{/api/v4/buckets/data/\{task\_id\}}.
    \item \textbf{Archivos en Cuarentena:} Archivos movidos al directorio de cuarentena.
    \item \textbf{Registros de Actividad (Logs):} Salida de texto estructurada en la consola.
    \item \textbf{Archivos Descargados:} Archivos escritos en el disco local.
\end{itemize}

\subsection{Justificación de Decisiones de Diseño}
La arquitectura y tecnología de un proyecto son el resultado de una serie de decisiones deliberadas para resolver un problema específico. A continuación, se justifican las elecciones más importantes en el desarrollo del \textit{Nez-Daemon Watcher}.

\subsubsection{Elección de Python y Asyncio}
Para un servicio cuya principal función es esperar y gestionar operaciones de entrada/salida (I/O) —como monitorear el sistema de archivos y realizar peticiones de red—, un modelo de concurrencia asíncrono es ideal. Python, a través de su ecosistema \texttt{asyncio}, permite manejar miles de operaciones concurrentes con un solo hilo, evitando la sobrecarga de memoria y conmutación de contexto asociada al multithreading tradicional. Esto se traduce en un sistema altamente eficiente y escalable para tareas I/O-bound.

\subsubsection{Uso de una Arquitectura Basada en Cola de Tareas}
La decisión de usar una cola de tareas (\texttt{asyncio.Queue}) como intermediario entre los productores de eventos y los consumidores (trabajadores) es fundamental para la robustez del sistema. Esta arquitectura desacoplada ofrece varias ventajas:
\begin{itemize}
    \item \textbf{Absorción de Picos:} Si se crean cientos de archivos simultáneamente, la cola los almacena de forma segura, permitiendo que los trabajadores los procesen a su propio ritmo sin perder ningún evento.
    \item \textbf{Resiliencia:} Si el proceso de un trabajador falla, solo afecta a la tarea actual. El resto de las tareas permanecen seguras en la cola, listas para ser procesadas.
    \item \textbf{Escalabilidad:} Es fácil aumentar la capacidad del sistema simplemente añadiendo más trabajadores que consuman de la misma cola.
\end{itemize}

\subsubsection{Elección de Socket de Dominio Unix para IPC}
Para la comunicación entre procesos (IPC) en la misma máquina, se eligió un socket de dominio Unix en lugar de un socket TCP/IP sobre localhost. Esta decisión se basa en que los sockets Unix son más eficientes y seguros: no tienen la sobrecarga del stack de red TCP/IP (handshakes, cabeceras, etc.) y su acceso puede ser controlado mediante los permisos del sistema de archivos, limitando qué procesos pueden comunicarse con el watcher.

\subsection{Seguridad del Sistema}
Aunque el watcher opera como un servicio de backend, se implementaron varias medidas para asegurar su operación.
\begin{itemize}
    \item \textbf{Comunicación Segura:} Se asume que la comunicación con el Router de MictlanX se realiza a través de HTTPS, protegiendo los datos en tránsito. La biblioteca \texttt{httpx} utilizada soporta TLS de forma nativa.
    \item \textbf{Gestión de la Configuración:} Siguiendo las mejores prácticas, no se almacenan secretos (como tokens de API) en el código. La dirección y posibles credenciales para MictlanX se gestionan a través de variables de entorno, separando la configuración del código.
    \item \textbf{Sanitización de Claves:} La función \texttt{sanitize\_key} elimina caracteres no alfanuméricos de las rutas de los archivos antes de usarlas como claves en MictlanX. Esto previene ataques de "path traversal" y asegura que las claves sean siempre válidas para la API de MictlanX.
    \item \textbf{Permisos del Sistema de Archivos:} El servicio opera con los mínimos privilegios necesarios. Solo requiere permisos de lectura sobre el directorio vigilado y permisos de escritura sobre los directorios de descarga y de cuarentena.
\end{itemize}

\subsection{Configuración y Despliegue}
La flexibilidad del sistema se basa en su configuración externa y su empaquetado para un despliegue sencillo.

\subsubsection{Variables de Entorno}
El comportamiento del watcher se controla mediante las siguientes variables de entorno:
\begin{itemize}
    \item \texttt{LOG\_LEVEL}: Define el nivel de detalle de los logs (ej. INFO, DEBUG).
    \item \texttt{WATCH\_DIRECTORY}: Ruta absoluta al directorio que será monitoreado.
    \item \texttt{QUARANTINE\_DIRECTORY}: Ruta absoluta al directorio donde se moverán los archivos fallidos.
    \item \texttt{MICTLANX\_URI}: El URI completo para conectarse al Router de MictlanX, incluyendo protocolo, host, puerto y credenciales si son necesarias.
    \item \texttt{BUCKET\_ID}: El nombre del "Bucket" en MictlanX donde se almacenarán los archivos.
    \item \texttt{REPLICATION\_FACTOR}: Número de réplicas que MictlanX debe crear para cada archivo.
    \item \texttt{MAX\_WORKERS}: Número de trabajadores concurrentes para procesar la cola de tareas.
\end{itemize}

\subsubsection{Despliegue con Docker}
El `Dockerfile` del proyecto define el proceso de empaquetado. Los pasos más relevantes son:
\begin{enumerate}
    \item Se utiliza una imagen base oficial de Python (\texttt{python:3.12-slim}) para minimizar el tamaño.
    \item Se copia y se instala primero la dependencia local \texttt{mictlanx-client}, ya que es un prerrequisito.
    \item Se instalan el resto de las dependencias listadas en \texttt{requirements.txt}.
    \item Finalmente, se copia el código fuente del watcher y se define el comando de inicio (\texttt{CMD}).
\end{enumerate}
Para ejecutar el servicio, se utilizaría un comando \texttt{docker run} que monte los directorios locales como volúmenes y pase la configuración a través de variables de entorno.

\subsection{Manejo de Errores y Resiliencia}
Un aspecto clave del diseño es la capacidad del sistema para operar de forma desatendida y recuperarse de problemas comunes.
\begin{itemize}
    \item \textbf{Comprobación de Salud Inicial:} Antes de iniciar el bucle principal, el watcher realiza una llamada de "health check" al Router de MictlanX. Si el servicio de almacenamiento no está disponible, el watcher termina con un error, evitando operar en un estado degradado.
    \item \textbf{Reintentos con Retroceso Exponencial:} Todas las llamadas a la API de MictlanX están envueltas en una lógica de reintentos automáticos. Si una llamada falla por un problema de red transitorio, el sistema esperará un tiempo (que aumenta exponencialmente con cada fallo) antes de reintentar, hasta un máximo de intentos configurado.
    \item \textbf{Mecanismo de Cuarentena:} Si un archivo falla todos los reintentos, se considera "venenoso" (poison pill). En lugar de bloquear la cola para siempre, el archivo es movido a un directorio de cuarentena. Esto libera al sistema para que continúe procesando otras tareas y permite que un administrador investigue el problema de forma manual.
\end{itemize}

\subsection{Algoritmos Principales}
A continuación se describen los algoritmos que definen el flujo de control y la lógica de negocio del Watcher.

\subsubsection{Algoritmo del Trabajador Principal}
Este algoritmo representa el bucle de eventos de cada trabajador, responsable de consumir tareas y despacharlas a la lógica apropiada.

\begin{algorithm}
\caption{Procesamiento de Tareas del Trabajador}
\begin{algorithmic}[1]
\While{el sistema está activo}
    \State \texttt{tarea} $\leftarrow$ esperar y obtener de \texttt{ColaDeTareas}
    \If{\texttt{tarea} es un evento de archivo}
        \State \texttt{ruta\_archivo} $\leftarrow$ obtener ruta de \texttt{tarea}
        \If{\texttt{ruta\_archivo} es una solicitud de descarga}
            \State \Call{procesarSolicitudDeDescarga}{\texttt{ruta\_archivo}}
        \Else
            \State \Call{esperarEstabilidadDeArchivo}{\texttt{ruta\_archivo}}
            \If{\Call{archivoYaExisteEnMictlanX}{\texttt{ruta\_archivo}}}
                \State registrar "Archivo ya existe, omitiendo."
                \State \textbf{continue}
            \EndIf
            \If{\Call{subirArchivoAMictlanX}{\texttt{ruta\_archivo}} es exitoso}
                 \State registrar "Archivo subido con éxito."
            \Else
                 \State registrar "Fallo en la carga del archivo."
                 \State \Call{moverArchivoACuarentena}{\texttt{ruta\_archivo}}
            \EndIf
        \EndIf
    \ElsIf{\texttt{tarea} es una solicitud de socket}
        \State \texttt{ruta\_descarga} $\leftarrow$ obtener ruta de \texttt{tarea}
        \State \Call{procesarDescargaDesdeSocket}{\texttt{ruta\_descarga}}
    \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\subsubsection{Justificación y Utilidad del Patrón Worker}
Este algoritmo, basado en el patrón de productor-consumidor, es el motor que impulsa toda la lógica de negocio del \textit{Nez-Daemon Watcher}. Su diseño responde a la necesidad de gestionar eventos que ocurren en momentos impredecibles y concurrentes, como la creación de archivos o las peticiones por socket. Un diseño secuencial simple se bloquearía con la primera tarea de larga duración, volviéndose incapaz de responder a nuevos eventos. La solución implementada resuelve esto mediante un bucle de eventos con una cola de tareas. El bucle infinito (`While el sistema está activo`) establece al trabajador como un proceso persistente, siempre listo para operar. El punto más crítico es la línea `tarea <- esperar y obtener de ColaDeTareas`, donde la cola actúa como un búfer que absorbe los picos de trabajo y desacopla la detección de eventos de su procesamiento. Los productores (el observador de archivos y el servidor de socket) simplemente añaden tareas a la cola sin esperar a que se completen. El bloque `If/ElsIf` funciona como un enrutador que despacha cada tipo de tarea a la lógica correspondiente, permitiendo que el mismo pool de trabajadores maneje distintas operaciones. Al ejecutar múltiples instancias de este algoritmo en paralelo, el sistema logra la concurrencia, maximizando el uso de recursos. Este patrón transforma un flujo de eventos caótico en un proceso de trabajo ordenado, concurrente y robusto.

\subsubsection{Algoritmo de Carga de Archivo a MictlanX}
Este algoritmo es crucial, pues su diseño de dos pasos es una consecuencia directa de la arquitectura desacoplada de MictlanX. La separación del registro de metadatos y la carga de datos permite al Router coordinar la replicación y preparar a los Peers antes de recibir el contenido, aumentando la escalabilidad y robustez del VSS.

\begin{algorithm}
\caption{Carga de Archivo a MictlanX}
\begin{algorithmic}[1]
\Procedure{subirArchivoAMictlanX}{\texttt{ruta\_archivo}}
    \State \texttt{checksum} $\leftarrow$ \Call{calcularSHA256}{\texttt{ruta\_archivo}}
    \State \texttt{tamaño} $\leftarrow$ \Call{obtenerTamaño}{\texttt{ruta\_archivo}}
    \State \texttt{clave} $\leftarrow$ \Call{sanitizarRutaRelativa}{\texttt{ruta\_archivo}}
    
    \State \texttt{metadatos} $\leftarrow$ crear estructura con \texttt{bucket\_id}, \texttt{clave}, \texttt{checksum}, \texttt{tamaño}, \texttt{replication\_factor}
    
    \State \textit{// Paso 1: Registrar metadatos en el Router}
    \State \texttt{respuesta\_meta} $\leftarrow$ \Call{POST}{"/api/v4/buckets/metadata", \texttt{metadatos}}
    \If{\texttt{respuesta\_meta} es un error}
        \State \Return \texttt{falso}
    \EndIf
    \State \texttt{id\_tarea} $\leftarrow$ \Call{obtenerID}{\texttt{respuesta\_meta}}
    
    \State \textit{// Paso 2: Subir contenido de datos al Router usando el ID de tarea}
    \State \texttt{respuesta\_datos} $\leftarrow$ \Call{POST}{"/api/v4/buckets/data/\texttt{id\_tarea}", \texttt{ruta\_archivo}}
    \If{\texttt{respuesta\_datos} es un error}
        \State \Return \texttt{falso}
    \EndIf
    
    \State \Return \texttt{verdadero}

\end{algorithmic}
\end{algorithm}

\subsubsection{Justificación y Utilidad del Proceso de Carga en Dos Pasos}
A primera vista, el algoritmo para cargar un archivo podría parecer innecesariamente complejo, ya que una simple petición HTTP PUT con el contenido del archivo parecería suficiente. Sin embargo, este diseño de dos pasos (primero metadatos, luego datos) es una decisión deliberada y crucial que resuelve problemas fundamentales inherentes a los sistemas de almacenamiento distribuido como MictlanX. El problema principal a resolver es cómo cargar un archivo de forma fiable a un sistema complejo donde el destino final no se conoce de antemano y los errores de red son comunes. La solución implementada es un protocolo que separa la "negociación" (plano de control) de la "transferencia" (plano de datos). La primera fase, el registro de metadatos, actúa como el plano de control. La llamada a la API (`POST /api/v4/buckets/metadata`) no transfiere el archivo, sino que comunica la \textit{intención} de subirlo con ciertas características (nombre, tamaño, checksum, factor de replicación). Esta negociación permite al Router de MictlanX realizar operaciones críticas de forma anticipada, como la validación de permisos y la planificación del almacenamiento, donde consulta al SPM para seleccionar los Peers más adecuados. Una ventaja clave de este paso es la capacidad de **fallar rápido (fail-fast)**. Si alguna condición previa no se cumple, el Router devuelve un error inmediato, y el Watcher evita el coste de transferir un archivo que sería rechazado, ahorrando tiempo y ancho de banda. La segunda fase, la carga de datos, representa el plano de datos. Solo si el primer paso tiene éxito, el Router devuelve un "ID de tarea" que representa una transacción de carga aprobada. La segunda llamada a la API (`POST /api/v4/buckets/data/\{id\_tarea\}`) utiliza este identificador para transferir el contenido binario. Este enfoque dota al proceso de una atomicidad simplificada, ya que los datos solo se envían después de que el sistema ha confirmado formalmente que está listo para recibirlos, previniendo estados inconsistentes. Además, esta separación de responsabilidades es lo que permite la escalabilidad del ecosistema MictlanX, optimizando la gestión de metadatos y la transferencia de datos de forma independiente.

